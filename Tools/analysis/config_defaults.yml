results:
    xml_files:
        'results/report.xml':
            total_raw: 'timings/timer[name="Total"]/mean'
            sites: 'geometry/sites'
            images_count: 'results/images'
            snapshots_count: results/snapshots
            domain_decomposition: 'timings/timer[name="Domain Decomposition"]/mean'
            file_read: 'timings/timer[name="File Read"]/mean'
            net: 'timings/timer[name="Net initialisation"]/mean'
            lb: 'timings/timer[name="Lattice Boltzmann"]/mean'
            lb_calc_only: 'timings/timer[name="LB calc only"]/mean'
            visualisation_raw: 'timings/timer[name="Visualisation"]/mean'
            monitoring: 'timings/timer[name="Monitoring"]/mean'
            send: 'timings/timer[name="MPI Send"]/mean'
            wait: 'timings/timer[name="MPI Wait"]/mean'
            snapshots_raw: 'timings/timer[name="Snapshots"]/mean'
            simulation_raw: 'timings/timer[name="Simulation total"]/mean'
            steps: results/steps/total
            snapshot_normalisation: 'timings/timer[name="Snapshots"]/normalisation'
            changeset: build/revision
            reading_group_raw: build/reading_group
            seed_decomposition: 'timings/timer[name="Seed Decomposition"]/mean'
            re_read: 'timings/timer[name="Re Read"]/mean'
            unzip: 'timings/timer[name="Unzip"]/mean'
            moves: 'timings/timer[name="Moves"]/mean'
            parmetis: 'timings/timer[name="Parmetis"]/mean'
            reading_preliminaries: 'timings/timer[name="Read Blocks prelim"]/mean'
            reading_blocks: 'timings/timer[name="Read blocks all"]/mean'
            reading_communications: 'timings/timer[name="Reading communications"]/mean'
            steering_wait_raw: 'timings/timer[name="Steering Client Wait"]/local'
            steering_wait_raw_2: 'timings/timer[name="Steering Client Wait Time"]/local'
            parsing: 'timings/timer[name="Parsing"]/mean'
            read_io: 'timings/timer[name="Read IO"]/mean'
            block_count: 'geometry/blocks'
            sites_per_block: 'geometry/sites_per_block'
            dbg1: 'timings/timer[name="dbg1"]/mean'
            dbg2: 'timings/timer[name="dbg2"]/mean'
            dbg3: 'timings/timer[name="dbg3"]/mean'
            dbg4: 'timings/timer[name="dbg4"]/mean'
            dbg5: 'timings/timer[name="dbg5"]/mean'
            lattice_type: build/lattice_type
            lb_kernel: build/kernel_type
            wall_boundary_condition: build/wall_boundary_condition
        'config.xml':
            cyclesteps: ['simulation','cyclesteps']
            cycles: ['simulation','cycles']
            step_length: ['simulation','step_length']
            inlet_pressure_mean: ['inlets/inlet/pressure','mean']
            inlet_pressure_amplitude: ['inlets/inlet/pressure','amplitude']
            inlet_pressure_period: ['inlets/inlet/pressure','period']
            outlet_pressure_mean: ['outlets/outlet/pressure','mean']
            sampling_frequency: ['properties/propertyoutput','frequency']
        'tests.xml':
            total_tests: 'Statistics/Tests'
            failing_tests: 'Statistics/FailuresTotal'
    text_files:
        'results/report.txt':
            cores: 'Ran with ([\d]+) threads'
        'CMakeCache.txt':
            build_type: 'CMAKE_BUILD_TYPE:STRING=(.*)'
            streaklines: 'HEMELB_USE_STREAKLINES:BOOL=(.*)'
        'acceptance.txt':
            acceptance: 'Accepted: (.*)'
    gmy_files:
        'config.gmy':
            gmy_fluid_site_count: site_count
            gmy_block_size: block_size
            gmy_block_count: block_count
    name_properties:
        machine_by_name: '(legion|hector|oppenheimer|planck|julian|localhost)'
        type_by_name: '(regression|unittests)'
        name: '(.*)'
    stat_properties:
        'results/report.txt':
            report_created_timestamp: st_mtime
        'tests.xml':
            test_results_timestamp: st_mtime
    mercurial_properties: #Properties based on the mercurial build number
        revision: '{rev}'
        revision_date: '{date|isodate}'
        branch: '{branch}'
    ssv_files:
      'steering_results.txt':
        steering_step: 0
        steering_elapsed_steps: 1
        steering_latitude: 2
        steering_longitude: 3
        steering_elapsed_time: 4
        steering_pixels: 5


    compound_properties:
        result_timestamp: (report_created_timestamp if report_created_timestamp else test_results_timestamp)
        snapshots_norm: (snapshots_count if normalised else 1.0)
        images_norm: (images_count if normalised else 1.0)
        steering_wait: (steering_wait_raw if steering_wait_raw else steering_wait_raw_2 if steering_wait_raw_2 else 0)
        snapshots: (snapshots_raw * snapshots_norm)
        visualisation: (visualisation_raw * images_norm)
        lb_calc_rate: (sites*steps*1.0)/((cores-1.0)*lb)
        velocity: (sites*steps*1.0/(cores*non_io))
        setup_velocity: (sites*1.0/(cores*setup))
        decomposition_velocity: (sites*1.0/(cores*domain_decomposition))
        need_strategy: ('list' if revision>1738 else 'deal')
        read_velocity: (sites*1.0/(cores*file_read))
        snapshot_velocity: (sites*snapshots_count*1.0/(cores*snapshots))
        visualisation_velocity: (sites*images_count*1.0/(cores*visualisation))
        non_io: (simulation- snapshots - visualisation)
        simulation: (simulation_raw-steering_wait)
        total: (total_raw-steering_wait)
        setup: total-simulation
        sites_per_core: (sites*1.0/cores)
        core_hours: (total*cores*1.0/(60*60))
        kau: (total*cores*125*1.0/(20000*60*60)) #20000 core hours is 125 kAU
        cost: (5.78*kau)
        report_created: (datetime.datetime.fromtimestamp(result_timestamp))
        geometry_type: ('old' if normalised else 'new')
        normalised: (True if snapshot_normalisation else False)
        solid_and_fluid_sites: block_count*sites_per_block
        fluid_fraction: sites*1.0/solid_and_fluid_sites
        gmy_sites_per_block: gmy_block_size**3
        gmy_fluid_fraction: gmy_fluid_site_count*1.0/(gmy_sites_per_block*gmy_block_count)
        reading_group: reading_group_raw if reading_group_raw else 5
        steering_frame_rate: float(len(steering_elapsed_time))/sum(steering_elapsed_time)
        steering_steps_per_frame: sum(steering_elapsed_steps)/float(len(steering_elapsed_steps))
        viscosity: (4e-3)
        blood_density: (1000.0)
        
        # Geometry stats
        pipe_length: 'math.sqrt(sum((x - y)**2 for x, y in zip(pipe_ends[0], pipe_ends[1])))' # todo: #493 numpyfy expression when possible: np.linalg.norm(pipe_ends[0] - pipe_ends[1])
        axis: '[(x-y) / pipe_length for x, y in zip(pipe_ends[1], pipe_ends[0])]'
        axial_position: '[x[2] for x in  aligned_cylindrical(raw_axial_coordinate,voxel_size,origin, axis)]'
        axial_radius: '[x[0] for x in  aligned_cylindrical(raw_axial_coordinate,voxel_size,origin, axis)]'
        radial_position: '[x[0] for x in aligned_cylindrical(raw_radial_coordinate,voxel_size,origin, axis)]'
        radial_z: '[x[2] for x in aligned_cylindrical(raw_radial_coordinate,voxel_size,origin, axis)]'

        # Velocity stats
        axial_velocity: '[sum([x*y for x,y in zip(axis, velocity)]) for velocity in radial_velocity_field]'
        mean_theoretical_axial_velocity: ' sum(theoretical_axial_velocity) / len(theoretical_axial_velocity)'
        range_theoretical_axial_velocity: 'max(theoretical_axial_velocity) - min(theoretical_axial_velocity)'
        residual_velocity: '[(a-b) for a,b in zip(axial_velocity,theoretical_axial_velocity)]'
        max_rel_residual_velocity: 'max([abs(x) for x in residual_velocity])/range_theoretical_axial_velocity'
        ave_rel_residual_velocity: '((sum([x**2 for x in residual_velocity])/len(residual_velocity))**0.5) / range_theoretical_axial_velocity'
        mean_actual_velocity: 'sum(axial_velocity)/len(axial_velocity)'

        # Pressure stats
        pressure_diff: (inlet_pressure_mean-outlet_pressure_mean) * 133.3223874
        axial_pressure: '[133.3223874 * x for x,y in zip(axial_pressure_torr, axial_position) if abs(y) < pipe_length/4]'
        axial_mean_pressure: sum(axial_pressure)/len(axial_pressure)
        mean_theoretical_axial_pressure: 'sum(theoretical_axial_pressure) / len(theoretical_axial_pressure)'
        range_theoretical_axial_pressure: 'max(theoretical_axial_pressure) - min(theoretical_axial_pressure)'
        residual_pressure: '[(a-b) for a,b in zip(axial_pressure,theoretical_axial_pressure)]'
        max_rel_residual_pressure: 'max([abs(x) for x in residual_pressure])/range_theoretical_axial_pressure'
        ave_rel_residual_pressure: '( sum([x**2 for x in residual_pressure]) / sum([(x - mean_theoretical_axial_pressure)**2 for x in theoretical_axial_pressure])) ** 0.5'
        mean_actual_pressure: '133.3223874*sum(axial_pressure)/len(axial_pressure)'

        # Inlet stats
        inlet_pressure: '[133.3223874 * x for x in inlet_pressure_torr]'
        inlet_V: '[ (x[0]**2 + x[1]**2 + x[2]**2) ** 0.5 for x in inlet_velocity  ]'

        # Scalar shear stress stats
        filtered_theoretical_shear_stress: '[a for (a,b) in zip(theoretical_axial_stress,radial_shear_stress_field) if not math.isinf(b)]'
        filtered_shear_stress: '[x for x in radial_shear_stress_field if not math.isinf(x)]'
        mean_actual_stress: 'sum(filtered_shear_stress)/len(filtered_shear_stress)'
        mean_filtered_theoretical_stress: 'sum(filtered_theoretical_shear_stress)/len(filtered_theoretical_shear_stress)'
        mean_theoretical_stress: 'sum(theoretical_axial_stress) / len(theoretical_axial_stress)'
        range_theoretical_stress: 'max(theoretical_axial_stress) - min(theoretical_axial_stress)'
        residual_stress: '[(a-b) for a,b in zip(radial_shear_stress_field,theoretical_axial_stress)]'
        max_rel_residual_stress: 'max([abs(x) for x in residual_stress if not math.isinf(x)])/range_theoretical_stress'
        ave_rel_residual_stress: '( sum([x**2 for x in residual_stress if not math.isinf(x)]) / sum([(x - mean_theoretical_stress)**2 for x in theoretical_axial_stress])) ** 0.5'

        # Reynolds number stats
        actual_reynolds_number: 1000*max(axial_velocity)*2*pipe_radius/viscosity
        theoretical_reynolds_number: 1000*max(theoretical_axial_velocity)*2*pipe_radius/viscosity

        # Full stress tensor stats
        # z-coordinate for all the sites where we sampled values of stress tensor and its theoretical pressure value
        stress_tensor_sampling_z_coord: '[x[2] for x in space(radial_coordinate_tensors,voxel_size,origin)]' 
        # Frobenius norm of the difference between the extracted tensor and the Poiseuille theoretical
        norm_residual_stress_tensor: '[frobenius_norm(theoretical-computed) for (theoretical, computed) in zip(theoretical_stress_tensor, radial_stresstensor)]'

    yaml_files:
        'env.yml':
            type: script
            machine: machine_name
            size: VoxelSize
            profile: profile
            node_type: node_type
        'config.smy':
            flow_type: flow_type
            pipe_radius: radius
            pipe_ends: ends

    optional_properties:
        # If no flow type was defined in config.smy, we assume it's Poiseuille flow (for backwards compatibility reasons)
        'flow_type==None':
            compound_properties:
                flow_type: '"poiseuille"'

        'flow_type=="poiseuille"':
            compound_properties:
                theoretical_axial_velocity:  '[ (1/(4*viscosity)) * (pressure_diff/pipe_length) * (pow(pipe_radius,2) - pow(d,2)) for d in radial_position]'
                theoretical_axial_pressure: '[inlet_pressure_mean*133.3223874 - pressure_diff * (x + pipe_length/2)/pipe_length for x in axial_position if abs(x) < pipe_length/4]'
                theoretical_axial_stress: '[0.5 * (pressure_diff/pipe_length) * r for r in radial_position] '
                theoretical_radial_pressure: '[inlet_pressure_mean*133.3223874 - pressure_diff * (z + pipe_length/2)/pipe_length for z in stress_tensor_sampling_z_coord]'
                theoretical_stress_tensor: '[poiseuille_stress_tensor(pipe_radius, pressure, pressure_diff/pipe_length) for (pipe_radius, pressure) in zip(radial_position, theoretical_radial_pressure)]'

        'flow_type=="womersley"':
            compound_properties:
                womersley_number: 'pipe_radius * math.sqrt((2.0 * numpy.pi * blood_density) / (viscosity * inlet_pressure_period))'
                theoretical_axial_velocity:  '[womersley_velocity(r, sampling_frequency * step_length, womersley_number, pipe_radius, pipe_length, inlet_pressure_amplitude * 133.3223874, inlet_pressure_period, blood_density) for r in radial_position]' # todo: #493 call womersley_velocity with radial_position once it becomes a numpy array

            
    extraction_files:
      'results/Extracted/pressure_axial_profile.dat':
        axial_field_count: fieldCount
        axial_pressure_torr: axial_pressure
        raw_axial_coordinate: grid
        voxel_size: voxelSizeMetres
        origin: originMetres
      'results/Extracted/velocity_shearstress_line_2_5_lengths_in.dat':
        radial_velocity_field: developed_velocity_profile
        radial_shear_stress_field: developed_shear_stress_profile
        raw_radial_coordinate: grid
        
      'results/Extracted/inlet_profile.dat':
        inlet_pressure_torr: inlet_pressure
        inlet_velocity: inlet_velocity
        inlet_coordinate: grid
      'results/Extracted/stresstensor_line_2_5_lengths_in.dat':
        radial_stresstensor: developed_stresstensor_profile
        radial_coordinate_tensors: grid

graphs:
    performance_versus_size:
        name: "Performance on ${machine} versus number of sites"
        select:
            type: hemelb
        dependent:
          - non_io_total
        independent:
            - sites
    performance_versus_cores:
        name: "Performance on ${machine} versus count of cores"
        select:
            type: hemelb
        dependent:
            - non_io_total
        independent:
            - cores
    sites_versus_voxel_size:
      name: "Number of sites versus voxel size"
      select:
          type: hemelb
      curves:
          - profile
      dependent:
          - sites
      independent:
          - size
            
reports:
  performance_on_planck:
    name: "Performance report for Planck"
    defaults:
      select:
        machine: planck
        acceptance: OK
      curves:
        - build_number
    graphs:
      performance_versus_cores:
        curves:
          - sites
      performance_versus_size:
        curves:
          - cores
  performance_on_oppenheimer:
    name: "Performance report for Oppenheimer"
    defaults:
      select:
        machine: oppenheimer
        acceptance: OK
      curves:
        - build_number
    graphs:
      performance_versus_cores:
        curves:
          - sites
      performance_versus_size:
        curves:
          - cores
      sites_versus_voxel_size:
        curves:
          - cores
